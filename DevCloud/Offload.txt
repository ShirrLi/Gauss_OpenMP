%%writefile lab/simple.cpp
//==============================================================
// Copyright © 2020 Intel Corporation
//
// SPDX-License-Identifier: MIT
// =============================================================
#include<iostream>
#include<omp.h>
#include<ctime>
#include <stdlib.h>
using namespace std;
float A[2000][2000],B[2000][2000];
int NUM_THREADS=7;
int n;
void Initialize(int n)//初始化
{
    int i,j,k;
    for(i=0;i<n;i++)
    {
        for(j=0;j<i;j++){
            A[i][j]=0;//下三角元素初始化为零
            B[i][j]=0;
        }
        A[i][i]=1.0;//对角线元素初始化为1
        B[i][i]=1.0;
        for(j=i+1;j<n;j++){
            A[i][j]=rand();//上三角元素初始化为随机数
            B[i][j]=A[i][j];
        }
    }
    for(k=0;k<n;k++)
        for(i=k+1;i<n;i++)
            for(j=0;j<n;j++){
                A[i][j]+=A[k][j];//最终每一行的值是上一行的值与这一行的值之和
                B[i][j]+=B[k][j];
            }
}
int main() {
  int is_cpu;
  n=1000;
  Initialize(n);
  cout<<"n is "<<n<<".threads are "<<NUM_THREADS+1<<endl;
  
  // Add the target directive here, including the map clause.
  clock_t time_stt2 = clock();
  getenv("MANDATORY");
 #pragma omp target map(from:is_cpu) map(from:B[0:n][0:n],n)
  {
       is_cpu = omp_is_initial_device();
            int i,j,k;
            float tmp;
            #pragma omp parallel num_threads(NUM_THREADS),private(i,j,k,tmp)
            for(k=0;k<n;k++){
             #pragma omp single
            {
                tmp=B[k][k];
                for(j=k+1;j<n;j++)
                    B[k][j]/=tmp;
                B[k][k]=1;
            }
            #pragma omp for
            for(i=k+1;i<n;i++){
                tmp=B[i][k];
                for(j=k+1;j<n;j++)
                    B[i][j]-=tmp*B[k][j];
                B[i][k]=0;
            }
        }
                
    }
   cout<<1000 * (clock() - time_stt2)/(double)CLOCKS_PER_SEC<<endl;
  // Print Output
  std::cout << "Running on " << (is_cpu ? "CPU" : "GPU") << "\n";
  return 0;
}
